# API Contract: FixtureValidator
# Feature: 004-dat-fixtures
# Date: 2025-10-14

contract:
  name: FixtureValidator
  description: Validates .DAT fixture integrity (manifest, files, checksums)
  module: iris_devtools.fixtures.validator
  class: FixtureValidator

constructor:
  signature: __init__()
  description: Initialize fixture validator (stateless, no connection required)
  returns:
    type: FixtureValidator
    description: Initialized validator instance

methods:
  - name: validate_fixture
    signature: validate_fixture(fixture_path: str, validate_checksums: bool = True) -> ValidationResult
    description: Validate fixture manifest, files, and checksums
    parameters:
      - name: fixture_path
        type: str
        required: true
        description: Path to fixture directory
      - name: validate_checksum
        type: bool
        required: false
        description: Validate IRIS.DAT checksum (default: True, slower but safer)
    returns:
      type: ValidationResult
      description: Validation result with errors, warnings, and manifest if valid
    raises:
      - exception: FileNotFoundError
        when: Fixture directory doesn't exist
    validation_checks:
      - "Fixture directory exists"
      - "manifest.json exists and is valid JSON"
      - "manifest.json schema is supported (1.0)"
      - "All required fields present (fixture_id, version, namespace, dat_file, checksum, tables)"
      - "IRIS.DAT file exists"
      - "IRIS.DAT checksum matches manifest (if validate_checksum=True)"
      - "No duplicate table names in manifest"
      - "Row counts are non-negative"
    examples:
      - description: Validate fixture with checksums
        code: |
          validator = FixtureValidator()
          result = validator.validate_fixture("./fixtures/test-100")
          if result.valid:
              print("✅ Fixture is valid")
              print(f"Tables: {len(result.manifest.tables)}")
          else:
              print(f"❌ Validation failed:")
              for error in result.errors:
                  print(f"  - {error}")
      - description: Fast validation (skip checksum)
        code: |
          result = validator.validate_fixture(
              "./fixtures/test-100",
              validate_checksum=False
          )

  - name: validate_manifest
    signature: validate_manifest(manifest: FixtureManifest) -> ValidationResult
    description: Validate manifest structure and contents (no file checks)
    parameters:
      - name: manifest
        type: FixtureManifest
        required: true
        description: Manifest to validate
    returns:
      type: ValidationResult
      description: Validation result (only checks manifest fields, not files)
    validation_checks:
      - "Required fields present (fixture_id, version, schema_version, namespace, dat_file, checksum, tables)"
      - "Schema version supported"
      - "Tables list not empty"
      - "No duplicate table names"
      - "Checksum format valid (sha256:...)"
      - "Row counts non-negative"
      - "dat_file field is 'IRIS.DAT'"
    examples:
      - description: Validate manifest object
        code: |
          manifest = FixtureManifest.from_file("./fixtures/test-100/manifest.json")
          validator = FixtureValidator()
          result = validator.validate_manifest(manifest)

  - name: calculate_sha256
    signature: calculate_sha256(file_path: str) -> str
    description: Calculate SHA256 checksum for file (streaming for large files)
    parameters:
      - name: file_path
        type: str
        required: true
        description: Path to file
    returns:
      type: str
      description: SHA256 checksum (format: "sha256:abc123...")
    raises:
      - exception: FileNotFoundError
        when: File doesn't exist
    performance:
      chunk_size: 64KB (optimal for streaming)
      speed: ~500 MB/s (varies by disk speed)
    examples:
      - description: Calculate checksum for .DAT file
        code: |
          validator = FixtureValidator()
          checksum = validator.calculate_sha256("./RAG.Entities.dat")
          print(f"Checksum: {checksum}")

  - name: validate_checksum
    signature: validate_checksum(file_path: str, expected_checksum: str) -> bool
    description: Validate file checksum matches expected value
    parameters:
      - name: file_path
        type: str
        required: true
        description: Path to file
      - name: expected_checksum
        type: str
        required: true
        description: Expected SHA256 checksum (format: "sha256:...")
    returns:
      type: bool
      description: True if checksum matches, False otherwise
    raises:
      - exception: FileNotFoundError
        when: File doesn't exist
      - exception: ValueError
        when: Invalid checksum format
    examples:
      - description: Validate .DAT file checksum
        code: |
          validator = FixtureValidator()
          valid = validator.validate_checksum(
              "./RAG.Entities.dat",
              "sha256:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
          )
          if not valid:
              print("❌ Checksum mismatch - file may be corrupted")

  - name: recalculate_checksums
    signature: recalculate_checksums(fixture_path: str) -> FixtureManifest
    description: Recalculate all checksums and update manifest
    parameters:
      - name: fixture_path
        type: str
        required: true
        description: Path to fixture directory
    returns:
      type: FixtureManifest
      description: Updated manifest with new checksums
    raises:
      - exception: FileNotFoundError
        when: Fixture or .DAT files missing
    side_effects:
      - "Updates manifest.json with new checksums"
      - "Creates manifest.json.backup before update"
    examples:
      - description: Recalculate checksums after manual .DAT file edit
        code: |
          validator = FixtureValidator()
          manifest = validator.recalculate_checksums("./fixtures/test-100")
          print("✅ Checksums recalculated and manifest updated")

  - name: get_fixture_size
    signature: get_fixture_size(fixture_path: str) -> Dict[str, int]
    description: Get fixture disk usage statistics
    parameters:
      - name: fixture_path
        type: str
        required: true
        description: Path to fixture directory
    returns:
      type: Dict[str, int]
      description: Size statistics (total_bytes, manifest_bytes, dat_files_bytes, file_count)
    examples:
      - description: Check fixture size before committing to git
        code: |
          validator = FixtureValidator()
          size = validator.get_fixture_size("./fixtures/test-100")
          total_mb = size["total_bytes"] / (1024 * 1024)
          print(f"Fixture size: {total_mb:.2f} MB")
          if total_mb > 10:
              print("⚠️  Consider using Git LFS for .DAT files >10MB")

behavior:
  stateless: Validator has no state (can be reused for multiple fixtures)
  thread_safety: Thread-safe (read-only operations)
  performance:
    - "Manifest validation: <100ms"
    - "Checksum validation (10MB file): <2 seconds"
    - "Full fixture validation (100MB): <10 seconds"

validation_errors:
  - code: MANIFEST_MISSING
    message: "manifest.json not found in fixture directory"
  - code: MANIFEST_INVALID_JSON
    message: "manifest.json contains invalid JSON"
  - code: MANIFEST_SCHEMA_UNSUPPORTED
    message: "Unsupported schema version: {version}"
  - code: REQUIRED_FIELD_MISSING
    message: "Required field missing: {field_name}"
  - code: DAT_FILE_MISSING
    message: "Referenced .DAT file not found: {file_path}"
  - code: CHECKSUM_MISMATCH
    message: "Checksum mismatch for {file_path}\n  Expected: {expected}\n  Actual: {actual}"
  - code: DUPLICATE_TABLE
    message: "Duplicate table name: {table_name}"
  - code: INVALID_ROW_COUNT
    message: "Invalid row count for {table_name}: {row_count} (must be >= 0)"

validation_warnings:
  - code: NO_DESCRIPTION
    message: "Fixture has no description"
  - code: LARGE_FILE
    message: "{file_path} is large ({size_mb}MB) - consider Git LFS"
  - code: OLD_SCHEMA_VERSION
    message: "Schema version {version} is outdated (current: 1.0)"

error_handling:
  strategy: Fail fast with detailed error reports
  message_format: |
    Fixture validation failed

    What went wrong:
      {error_list}

    How to fix it:
      1. Check manifest.json syntax
      2. Verify all .DAT files exist
      3. Recalculate checksums: validator.recalculate_checksums(...)

testing:
  contract_tests: tests/contract/test_fixture_validator_api.py
  unit_tests: tests/unit/test_validator.py
  performance_tests: tests/integration/test_fixture_performance.py

dependencies:
  - iris_devtools.fixtures.manifest - FixtureManifest, ValidationResult dataclasses
  - Standard library only (hashlib, json, os, pathlib)

constitutional_compliance:
  principle_5: Fail fast with guidance (clear validation errors with fix instructions)
  principle_7: Medical-grade reliability (100% checksum validation accuracy)
  principle_8: Document blind alleys (validation error codes explain what's wrong)
