# API Contract: FixtureCreator
# Feature: 004-dat-fixtures
# Date: 2025-10-14

contract:
  name: FixtureCreator
  description: Creates .DAT fixtures by exporting IRIS namespaces via database backup
  module: iris_devtools.fixtures.creator
  class: FixtureCreator

constructor:
  signature: __init__(connection_config: Optional[Dict[str, Any]] = None)
  description: Initialize fixture creator with optional connection configuration
  parameters:
    - name: connection_config
      type: Optional[Dict[str, Any]]
      required: false
      description: Connection configuration. If None, auto-discovers from environment.
  returns:
    type: FixtureCreator
    description: Initialized fixture creator instance
  raises:
    - exception: ConnectionError
      when: Cannot establish connection to IRIS

methods:
  - name: create_fixture
    signature: create_fixture(fixture_id: str, namespace: str, output_dir: str, description: str = "", version: str = "1.0.0", features: Optional[Dict[str, Any]] = None) -> FixtureManifest
    description: Export IRIS namespace to IRIS.DAT fixture with manifest
    parameters:
      - name: fixture_id
        type: str
        required: true
        description: Unique identifier for fixture (e.g., "test-entities-100")
      - name: namespace
        type: str
        required: true
        description: Source namespace to export (e.g., "USER", "USER_TEST_100")
      - name: output_dir
        type: str
        required: true
        description: Output directory for fixture (will be created if doesn't exist)
      - name: description
        type: str
        required: false
        description: Human-readable description of fixture
      - name: version
        type: str
        required: false
        description: Semantic version (default: "1.0.0")
      - name: features
        type: Optional[Dict[str, Any]]
        required: false
        description: Custom metadata to include in manifest
    returns:
      type: FixtureManifest
      description: Generated manifest with table info and checksums
    raises:
      - exception: FileExistsError
        when: Output directory already exists
        message: "Fixture directory already exists: {output_dir}\n\nWhat went wrong:\n  Cannot overwrite existing fixture\n\nHow to fix it:\n  1. Delete existing fixture: rm -rf {output_dir}\n  2. Choose different output path\n  3. Use update_fixture() to modify existing fixture"
      - exception: FixtureCreateError
        when: Namespace doesn't exist or backup fails
        message: "Failed to create fixture\n\nWhat went wrong:\n  {error_details}\n\nHow to fix it:\n  1. Verify namespace exists: Use IRIS Management Portal\n  2. Check permissions: User must have database backup access\n  3. Check disk space: df -h"
      - exception: RuntimeError
        when: Checksum calculation fails
    examples:
      - description: Create fixture from namespace
        code: |
          creator = FixtureCreator()
          manifest = creator.create_fixture(
              fixture_id="test-entities-100",
              namespace="USER_TEST_100",
              output_dir="./fixtures/test-entities-100",
              description="Test data with 100 RAG entities"
          )
          print(f"Created fixture with {len(manifest.tables)} tables")
      - description: Create fixture from namespace with metadata
        code: |
          manifest = creator.create_fixture(
              fixture_id="rag-full",
              namespace="RAG_PRODUCTION",
              output_dir="./fixtures/rag-full",
              description="Complete RAG dataset for integration tests",
              version="2.0.0",
              features={"use_case": "rag_testing", "dataset": "production_sample"}
          )

  - name: export_namespace_to_dat
    signature: export_namespace_to_dat(namespace: str, dat_file_path: str) -> str
    description: Export IRIS namespace to IRIS.DAT file using BACKUP^DBACK routine
    parameters:
      - name: namespace
        type: str
        required: true
        description: Source namespace to backup (e.g., "USER_TEST_100")
      - name: dat_file_path
        type: str
        required: true
        description: Output path for IRIS.DAT file
    returns:
      type: str
      description: Path to created IRIS.DAT file
    raises:
      - exception: RuntimeError
        when: Backup fails (namespace not found, permission denied, disk full)
    examples:
      - description: Export namespace to IRIS.DAT file
        code: |
          creator = FixtureCreator()
          dat_file = creator.export_namespace_to_dat(
              "USER_TEST_100",
              "./fixtures/test-100/IRIS.DAT"
          )
          print(f"Exported namespace to {dat_file}")

  - name: calculate_checksum
    signature: calculate_checksum(dat_file_path: str) -> str
    description: Calculate SHA256 checksum for .DAT file
    parameters:
      - name: dat_file_path
        type: str
        required: true
        description: Path to .DAT file
    returns:
      type: str
      description: SHA256 checksum (format: "sha256:abc123...")
    raises:
      - exception: FileNotFoundError
        when: .DAT file doesn't exist
    examples:
      - description: Calculate checksum for verification
        code: |
          checksum = creator.calculate_checksum("./RAG.Entities.dat")
          print(f"Checksum: {checksum}")

  - name: get_namespace_tables
    signature: get_namespace_tables(namespace: str) -> List[TableInfo]
    description: Get list of tables in namespace with row counts
    parameters:
      - name: namespace
        type: str
        required: true
        description: Namespace to inspect
    returns:
      type: List[TableInfo]
      description: List of tables with names and row counts
    raises:
      - exception: RuntimeError
        when: Namespace doesn't exist or query fails
    examples:
      - description: Inspect namespace before creating fixture
        code: |
          creator = FixtureCreator()
          tables = creator.get_namespace_tables("USER_TEST_100")
          for table in tables:
              print(f"{table.name}: {table.row_count} rows")

  - name: refresh_fixture
    signature: refresh_fixture(fixture_dir: str, namespace: str) -> FixtureManifest
    description: Refresh existing fixture by re-exporting namespace (updates all data)
    parameters:
      - name: fixture_dir
        type: str
        required: true
        description: Path to existing fixture directory
      - name: namespace
        type: str
        required: true
        description: Source namespace to re-export
    returns:
      type: FixtureManifest
      description: Updated manifest with new checksum and table list
    raises:
      - exception: FileNotFoundError
        when: Fixture directory doesn't exist
      - exception: RuntimeError
        when: Backup fails
    examples:
      - description: Refresh fixture after data changes
        code: |
          creator = FixtureCreator()
          manifest = creator.refresh_fixture(
              "./fixtures/test-100",
              namespace="USER_TEST_100"
          )
          print(f"Refreshed fixture, new checksum: {manifest.checksum}")

properties:
  - name: connection
    type: IRISConnection
    readonly: true
    description: Active IRIS connection

behavior:
  atomicity: Namespace backup is atomic (BACKUP^DBACK handles)
  idempotency: Overwrites existing IRIS.DAT if re-run (with FileExistsError check)
  thread_safety: Not thread-safe - each thread should create own instance
  performance:
    - "Namespace backup: <20 seconds for 10K rows"
    - "Large namespace: <120 seconds for 100K rows"
    - "Checksum calculation: <5 seconds (scales with IRIS.DAT size)"

file_structure:
  output_directory: |
    fixtures/{fixture_id}/
    ├── manifest.json
    └── IRIS.DAT

manifest_generation:
  schema_version: "1.0"
  timestamp_format: ISO 8601 (e.g., "2025-10-14T15:30:00Z")
  iris_version_detection: Query IRIS system version
  checksum_algorithm: SHA256
  checksum_format: "sha256:{64_hex_chars}"

error_handling:
  strategy: Fail fast with guidance (Constitutional Principle #5)
  cleanup_on_failure: Remove partial .DAT files if export fails midway
  message_format: |
    Failed to create fixture

    What went wrong:
      {error_details}

    How to fix it:
      1. {step_1}
      2. {step_2}

testing:
  contract_tests: tests/contract/test_fixture_creator_api.py
  unit_tests: tests/unit/test_creator.py
  integration_tests: tests/integration/test_dat_fixtures_integration.py

dependencies:
  - Feature 003 (Connection Manager) - Required for IRIS connectivity
  - iris_devtools.fixtures.manifest - FixtureManifest, TableInfo dataclasses
  - iris_devtools.fixtures.validator - Checksum calculation

constitutional_compliance:
  principle_2: DBAPI first (inherits from Feature 003 connection manager)
  principle_4: Zero configuration (auto-discovers IRIS connection)
  principle_5: Fail fast with guidance (structured error messages)
  principle_7: Medical-grade reliability (SHA256 checksums, verified row counts)
